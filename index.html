<html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" /><title>SQL as Data</title><link href="css/reveal.css" rel="stylesheet" type="text/css" /><link href="css/theme/black.css" rel="stylesheet" type="text/css" /><link href="lib/css/zenburn.css" rel="stylesheet" type="text/css" /></head><body><div class="reveal"><div class="slides"><section><h1>HoneySQL</h1><br /><h4>Chicago Clojure</h4><h6>July 20, 2016</h6><p><a href="https://github.com/emidln/honeysql-talk">https://github.com/emidln/honeysql-talk</a></p></section><section><p>about me</p><pre><code>{:name "Brandon Adams",
 :languages #{:clojure :java :c :python},
 :works-at "https://curiosity.com",
 :github "@emidln"}
</code></pre></section><section><p>&lt;Plug&gt; Curiosity.com &lt;/Plug&gt;</p><pre><code>{:languages #{:clojure :python},
 :databases #{:redis :postgresql :zookeeper :mongodb},
 :location "Ravenswood, Chicago, IL, USA",
 :hiring? true}
</code></pre></section><section><p>Why SQL?</p><ul><li class="fragment">popular databases ...<ul><li>Oracle, MySQL, PostgreSQL, MS SQL</li><li>SQLite, H2, and many more</li></ul></li><li class="fragment">because my boss said so</li></ul></section><section><p>SQL</p><br /><pre><code>SELECT * FROM foo WHERE id = 9 AND spam = 'blah';</code></pre><pre><code>UPDATE bar SET quux = 'spam' WHERE id = 37;</code></pre><pre><code data-trim="data-noescape">INSERT INTO pokedex (pokemon, name, level)
VALUES ('pikachu', 'Perry', 9);</code></pre></section><section><p>What is HoneySQL?</p><ul><li class="fragment">AST for SQL represented using Clojure data</li><li class="fragment">Helper library for friendly parameterized query construction</li><li class="fragment">Written by Justin Kramer (<a href="https://github.com/jkk">@jkk</a>) and maintained at <a href="https://github.com/jkk/honeysql">github.com/jkk/honeysql</a></li></ul></section><section><p>Basic HoneySQL</p><p>Inserts<pre><code>(-> (insert-into :cities)
    (values
     {:name "Chicago", :pizza-rank 1}
     {:name "New York", :pizza-rank 2}))
</code></pre><pre><code>(-> (insert-into :cities)
    (columns :name :pizza-rank)
    (values ["Chicago" 1] ["New York" 2]))
</code></pre></p><p>Updates<pre><code>(-> (update :cities) (sset {:rank 1}) (where [:= :name "New York"]))
</code></pre><pre><code>(-> (update :daily-sales)
    (sset {:total (call :+ :total 1)})
    (where [:= :date (raw "current_date")]))
</code></pre></p><p>Queries<pre><code>(-> (select :c.name :c.pizza-rank :p.population)
    (from [:cities :c])
    (join [:population :c] [:= :c.name :p.city-name])
    (order-by [:c.pizza-rank :asc])
    (limit 1))
</code></pre></p><p>Deletes<pre><code>(-> (delete-from :cities) (where [:< :rank 1]))
</code></pre></p></section><section><p>HoneySQL Provides An AST</p><pre><code>(=
 (-> (select :*) (from :foo) (where [:= :id 9] [:= :spam "blah"]))
 {:select '(:*),
  :from '(:foo),
  :where [:and [:= :id 9] [:= :spam "blah"]]})
</code></pre></section><section><p>and a library to take advantage of it</p><pre><code>(-> {:select '(:email),
     :from '(:fancy-hat-customers),
     :where [:> :disposable-income 10000]}
    (merge-where
     [:or
      [:= :favorite-color "blue"]
      [:= :favorite-team "cubs"]
      [:= :lives-in "Chicago"]]))
</code></pre><pre><code>{:select (:email),
 :from (:fancy-hat-customers),
 :where [:and
         [:> :disposable-income 10000]
         [:or
          [:= :favorite-color "blue"]
          [:= :favorite-team "cubs"]
          [:= :lives-in "Chicago"]]]}
</code></pre></section><section><p>You don't need HoneySQL if your queries are static</p><pre><code>(require '[clojure.java.jdbc :as jdbc])
(require 'clj-time.jdbc)
(defn find-foos-by-range [db start stop]
  (jdbc/query db ["SELECT * FROM foo WHERE ts BETWEEN ? and ?"]))
</code></pre></section><section><p>But if you need something a little more dynamic...</p><span class="fragment"><pre><code>(let [id 9, spam "blah"]
  (cond-> "SELECT * FROM foo WHERE"
    (some? id) (str " id = " id)
    (and (some? id) (some? spam)) (str " AND ")
    (some? spam) (str "spam = " spam)))
</code></pre></span><br /><spam class="fragment"><p>Have you done this?</p><p>Spot any potential bugs?</p></spam></section><section><p>SQL Injection?</p><p class="fragment">I forgot to insert driver-specific placeholders and track the values in an array so I can pass those separately to JDBC.</p><p>String building?</p><p class="fragment">I left out a space around spam. This will result in something like "WHEREspam=" if id isn't given.</p></section><section><p>Easy, right?</p><span class="fragment"><pre><code>(require 'clojure.java.jdbc)
(let [id 9
      spam "blah"
      selector (fn [id spam]
                 (let [params (atom [])]
                   [(cond-> "SELECT * FROM foo WHERE"
                      (some? id) (str " id = " id)
                      (and (some? id) (some? spam)) (str " AND ")
                      (some? spam)
                        (#(do (swap! params conj %) (str " spam = ?"))))
                    @params]))
      [sql & params] (selector id spam)]
  (apply clojure.java.jdbc/query db sql params))
</code></pre></span></section><section><p>Yikes! Maybe something does this for us?</p></section><section><p>HoneySQL the AST (cont'd)</p><pre><code>(require 'honeysql.core)
(require '[honeysql.helpers :refer :all])
(require 'clojure.java.jdbc)
(let [id 9
      spam "blah"
      selector (fn [id spam]
                 (-> (cond-> (-> (select :*) (from :foo))
                       (some? id) (merge-where [:= :id id])
                       (some? spam) (merge-where [:= :spam spam]))
                     honeysql.core/format))
      [sql & params] (selector id spam)]
  (apply clojure.java.jdbc/query db sql params))
</code></pre></section><section><p>AST Advantages</p><ul><li>Safety<ul><li>Let the library worry about parameters</li></ul></li><li>Tooling<ul><li>clojure.core</li><li>plumbing.core</li><li>your favorite utility library</li></ul></li></ul></section><section><p>By representing the AST as Clojure data structures, our core Clojure language can be used to easily manipulate a query</p><br /><p>Sound familiar?</p></section><section><p>HoneySQL Notes (part 1)</p><br /><ul><li>Maps nest as subqueries. If you want a map value to the JDBC layer use <a href="https://crossclj.info/doc/honeysql/0.7.0/honeysql.format.html#_value"><code>honeysql.format/value</code></a><pre><code>(-> (insert-into :meetups-pages)
    (values
     {:event 232391630,
      :meta (value
             {"keywords" ["USA"
                          "Illinois"
                          "Chicago"
                          "softwaredev"
                          "Clojurians"
                          "Meetup"],
              "geo.position" ["41.881966" "-87.632362"]})}))
</code></pre></li><li class="fragment">Vectors are handled by the individual clause. When it makes sense, it is used for aliasing.<pre><code>(from [:foo :f])
</code></pre><pre><code>(where [:= :bar "baz"])
</code></pre><pre><code>#sql/call [:+ :total 1]</code></pre></li></ul></section><section><p>HoneySQL Notes (part 2)</p><ul><li>Not all clauses have helpers. They are easy to define if you think it'll help readability:<pre><code>(defn union
  {:argslists '([& queries] [m & queries])}
  [& args]
  (let [[m & queries] (if (map? (first args)) args (cons {} args))]
    (assoc m :union (vec queries))))
</code></pre></li><li class="fragment">Raw SQL access is available, see <a href="https://crossclj.info/doc/honeysql/latest/honeysql.core.html#_raw"><code>honeysql.core/raw</code></a><pre><code>(raw "current_date")
</code></pre><pre><code>#sql/raw "current_date"</code></pre></li></ul></section><section><p>Extending HoneySQL Operators</p><pre><code>(require 'honeysql.format)
(defmethod
 honeysql.format/fn-handler
 "json-eq"
 [_ outer-key inner-key val]
 (format
  "%s->>'%s' = %s"
  outer-key
  inner-key
  (honeysql.format/to-sql val)))
(-> (select :*) (from :foo) (where [:json-eq "extra" "foo-id" 5]))
</code></pre></section><section><p>Extending HoneySQL Clauses</p><pre><code>(require 'honeysql.core)
(require '[honeysql.format :refer [comma-join format-clause to-sql]])
(require '[honeysql.helpers :refer :all])
(defmethod
 format-clause
 :returning
 [[_ fields] _]
 (str "RETURNING " (comma-join (map to-sql fields))))
(defhelper returning [m args] (assoc m :returning args))
(-> (update :foo)
    (sset
     {}
     {:count #honeysql.types.SqlCall{:name :+, :args (:count 1)}})
    (where [:= :id 99])
    (returning :count))
</code></pre></section><section><p>Using clojure.java.jdbc</p><p><pre><code>(require '[clojure.java.jdbc :as jdbc] '[cheshire.core :as json])
(import 'org.postgresql.util.PGobject)
(defn value-to-json-pgobject [value]
  (doto (PGobject.)
        (.setType "jsonb")
        (.setValue (json/generate-string value))))
</code></pre><pre><code>(extend-protocol
 jdbc/ISQLValue
 clojure.lang.IPersistentMap
 (sql-value [value] (value-to-json-pgobject value)))
(extend-protocol
 jdbc/IResultSetReadColumn
 org.postgresql.util.PGobject
 (result-set-read-column
  [pgobj metadata idx]
  (let [type (.getType pgobj), value (.getValue pgobj)]
    (if (#{"json" "jsonb"} type) (json/parse-string value true) value))))
</code></pre></p></section><section><p>Someone already did this for ...<p>Postgres: <a href="https://github.com/nilenso/honeysql-postgres">nilenso/honey-postgres</a></p><p>Joda Time: <a href="https://github.com/clj-time/clj-time/blob/master/src/clj_time/jdbc.clj">clj-time</a></p></p></section><section><p>Solid Alternatives</p><ul><li><a href="https://github.com/krisajenkins/yesql">yesql</a><ul><li>SQL is already a DSL, why do we need another abstraction?</li><li>parses SQL into clojure functions</li></ul></li><li><a href="http://hugsql.com/">HugSQL</a><ul><li>inspired by yesql</li><li>parses SQL into clojure functions</li><li>supports more use cases than yesql</li><li>actively maintained</li></ul></li></ul></section><section><p>Exercises</p><br /><p>See <a href="https://github.com/emidln/honeysql-talk">this talk's github</a> for examples of extending and using HoneySQL using <a href="https://pgexercises.com">PGExercises.com. A Dockerfile is included with instructions in the README.md to get started.</a></p></section></div></div><script src="lib/js/head.min.js" type="text/javascript"></script><script src="js/reveal.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
Reveal.initialize({
         width: 1000,
         height: 1000,
         history: true,
         dependencies: [
             { src: 'plugin/markdown/marked.js' },
             { src: 'plugin/markdown/markdown.js' },
             { src: 'plugin/notes/notes.js' },
             { src: 'plugin/highlight/highlight.js',
               async: true,
               callback: function() { hljs.initHighlightingOnLoad();} }]})
//]]></script></body></html>